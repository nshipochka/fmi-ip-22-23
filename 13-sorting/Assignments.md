## Task 1
Даден е масив от числа `nums`, който съдържа само елементи 0, 1 или 2. Пренаредете масива така, че всички елементи с една стойност да се намират един до друг в реда нули, единици и двойки.

```c++
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Input: nums = [2,0,1]
Output: [0,1,2]
```

## Task 2
Дадени са два низа `s` и `order`. Всички букви в `order` са уникални и задават някакъв ред, в който тези букви трябва да бъдат срещнати в `s`, т.е. ако някоя буква `x` се среща преди буква `y` в `order`, то при сортиране на `s`, `x` пак трябва да се среща преди `y`. Сортирайте `s` по това правило.

```c++
Input: order = "cba", s = "abcd"
Output: "cbad" // "dcba", "cdba", ... също са валидни наредби

Input: order = "cbafg", s = "abcd"
Output: "cbad"
```

## Task 3
Даден е низ `s`, който трябва да бъде сортиран в намаляващ ред според това кой символ колко пъти се среща.

_Забележка: Главните и малките букви в случая се считат за различни символи_

```c++
Input: s = "tree"
Output: "eert" // "eetr" също е валидно

Input: s = "cccaaa"
Output: "aaaccc" // "cccaaa" също е валидно

Input: s = "Aabb"
Output: "bbAa" // "bbaA" също е валидно
```

## Task 4
Даден е масив от цели числа `arr`, който трябва да се нареди така, че `arr[0] < arr[1] > arr[2] < arr[3] > ...`. Считаме, че входът е коректен и винаги ще има такава наредба.

```c++
Input: arr = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4] // [1,4,1,5,1,6] също е валидно

Input: arr = [1,3,2,2,3,1]
Output: [2,3,1,3,1,2]
```

## Task 5
Дадена е матрица `m x n` от цели числа. Сортирайте всеки неин диагонал в нарастващ ред и изведете на екрана резултата.

```c++
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]

Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]

```

## Task 6
Да се напише функция, която приема двумерен масив `arr[3][N]` от числа. 

`arr[0]` наричаме първичен ключ.
`arr[1]` наричаме вторичен ключ.
`arr[2]` наричаме стойност.

Тройката `(arr[0][i], arr[1][i], arr[2][i])` е по - малка от тройката `(arr[0][j], arr[1][j], arr[2][j])`, ако    
`arr[0][i] < arr[0][j]` или `arr[0][i] == arr[0][j] && arr[1][i] < arr[1][j]`


Сортирайте двумерния масив така, че за всяко `i < j` : `(arr[0][i], arr[1][i], arr[2][i]) < (arr[0][j], arr[1][j], arr[2][j])`.

```
Input: arr = [[4 7 4 9 4 12], [2 4 1 5 3 0], [1 2 3 4 5 6]]
Output: [[4 4 4 7 9 12], [1 2 3 4 5 0], [3 1 5 2 4 6]]
```  
